---
layout: post
title:  "Perfect Elimination Ordering in Chordal Graph"
date:   2019-03-10 23:30:00
author: ainta
tags: [algorithm, graph]
---

# 목차

- [1. 개요](#개요)
- [2. 기본](#기본)
- [3. 구현](#구현)
- [4. 문제풀이](#문제풀이)
- [5. 마무리](#마무리)
- [6. 참고자료](#참고자료)

# 개요

## Chordal Graph
 Chordal Graph란, 길이 4 이상의 모든 simple cycle이 chord를 포함하는 그래프를 말한다. 여기서 chord란 cycle에 포함되는 edge는 아니지만 cycle에 포함하는 두 vertex를 잇는 edge를 뜻한다. 즉, 어떤 4개 이상의 vertex를 고르더라도 그 vertex들로 이뤄진 induced subgraph가 simple cycle이 되지 않는 그래프이다. 

## Perfect Elimination Ordering

그래프 $$G = (V, E)$$의 ordering $$X$$가 모든 vertex $$v$$에 대해, $$v$$와 인접한 정점들 중 $$X$$에서 $$v$$보다 늦게 등장하는 정점들이 clique(완전그래프)를 이루는 ordering이라면 $$X$$를 $$G$$의 perfect elimination ordering이라고 한다. 그래프 $$G$$에 chord를 가지지 않는 길이 4 이상의 cycle이 존재한다면 cycle에 포함되는 vertex 중 처음으로 등장하는 vertex는 perfect elimination ordering의 조건을 만족할 수 없으므로 는 perfect elimination ordering이 존재하지 않는다. 또한, 모든 chordal graph에 대해 perfect elimination ordering이 존재함이 알려져 있다(이에 대한 증명과 perfect elimination ordering을 직접 찾는 방법을 이후에 알아볼 것이다). 즉, 그래프 $$G$$의 perfect elimination ordering이 존재함과 $$G$$가 chordal graph임은 동치이다.

## Finding a perfect elimination ordering in a chordal graph


- suboptimal algorithms

$$G = (V, E)$$의 perfect elimination ordering은 앞에서부터 순서대로 간단하게 구할 수 있다. 어떤 vertex $$v$$가 존재하여 $$v$$와 인접한 vertex들이 clique을 이루면 $$v$$를 ordering의 맨 뒤에 추가하고, $$G$$에서는 제거하는 과정을 반복하면 perfect elimination ordering이 나온다. 만약 모든 vertex가 제거되지 않았는데 조건을 만족하는 vertex $$v$$를 찾을 수 없다면 perfect elimination ordering이 없는 것이므로 chordal graph가 아니라는 사실 역시 판정할 수 있다.
이를 naive한 방법으로 구현하면  $$O(V^4)$$의 매우 느린 시간복잡도를 갖는 알고리즘이 된다. 이를 개선한 방법으로 다음과 같은 알고리즘을 생각할 수 있다. 각 vertex $$v$$에 대해 아직 제거되지 않은 vertex들 중 $$v$$와 인접한 vertex들의 집합을 $$N(v)$$,  내에서 서로 연결되지 않은 vertex 쌍의 개수를 $$C(v)$$라고 할 때 $$C(v)$$가 0이 되는 정점 을 queue에 넣고, queue의 head에 있는 정점을 제거하는 방식으로 perfect elimination ordering을 구할 수 있다. 정점 $$v$$를 제거할 때 $$v$$와 인접한 정점들의 $$C(v)$$ 값을 업데이트해주어야 한다. 자세한 알고리즘을 실제 코드로 표현하면 다음과 같다.

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<queue>
using namespace std;
const int N_ = 101000;
int n, m, C[N_], head, tail, vis[N_];
set<int>graph[N_];
queue<int>Q;
vector<int>Order;
map<int, int>Edge[N_];
int main() {
	int i, j, k;
	scanf("%d%d", &n, &m);
	for (i = 0; i < m; i++) {
		int a, b;
		scanf("%d%d", &a, &b);
		graph[a].insert(b);
		graph[b].insert(a);
		Edge[a][b] = Edge[b][a] = 1;
	}
	for (i = 1; i <= n; i++) {
		int sz = graph[i].size();
		C[i] = sz * (sz - 1) / 2; // C[i]는 i와 인접한 정점들 중 서로 인접하지 않은 정점 쌍의 개수
		vector<int>neighbor;
		for (auto &x : graph[i])neighbor.push_back(x);
		for (j = 0; j < neighbor.size(); j++) {
			for (k = j + 1; k < neighbor.size(); k++) {
				if (Edge[neighbor[j]].count(neighbor[k]))C[i]--; // C[i]는 i와 인접한 정점 쌍 전체에서 i를 포함하는 3-cycle의 개수를 빼서 구할 수 있다.
			}
		}
	}
	for (i = 1; i <= n; i++) {
		if (!C[i]) {
			Q.push(i); //C[i]가 0이면 i를 큐에 넣는다.
			vis[i] = 1;
		}
	}
	while (!Q.empty()) {
		int v = Q.front();
		Order.push_back(v);
		Q.pop();//큐의 head에 있는 정점 v를 ordering에 추가하고, 그래프에서 제거한다.
		int sz = graph[v].size(); 
		for (auto &w : graph[v]) {
			graph[w].erase(v); //v와 인접한 정점 w에 대해 간선 (v,w)를 제거
			C[w] += -graph[w].size() + (sz - 1); // w와 인접한 정점 중 v와 인접한 것은 |N(v)|-1개이므로 인접하지 않은 것은 |N(w)| - (|N(v)|-1)개이고, v를 제거했을 때 C[w]는 이 값만큼 감소한다.
			if (!C[w] && !vis[w]) { //C[w]가 0이 되면 큐에 추가한다.
				vis[w] = 1;
				Q.push(w);
			}
		}
	}
	if (Order.size() != n) {
		puts("0");
	}
	else {
		printf("1\n");
		for (auto &v : Order)printf("%d ", v);
	}
}
```

위 알고리즘에서 처음에 $C$ 배열을 초기화하는 부분을 제외하면 시간복잡도는 set을 $O(E)$번 접근하는 것이 결정하므로 $O(E log E)$의 시간복잡도를 가진다. 그러나 $C$ 배열 초기화에서 $O(VE)$ 시간이 걸릴 수 있기 때문에 충분히 빠르지 못하다. $C$ 배열 초기화는 모든 3-cycle을 구하면 쉬운데, 3-cycle의 개수는 $O(E \sqrt E)$개임이 알려져 있고, 또한 $O(E \sqrt E)$ 시간에 모든 3-cycle을 구하는 방법이 존재한다. 아이디어는 모든 edge $(u, v)$에 대해 $min(degree(u), degree(v))$의 총 합이 $O(E \sqrt E)$임을 이용하는 것이다.
C배열을 초기화하는 부분의 코드는 아래와 같다.

```cpp
	for (i = 0; i < m; i++) {
		int a, b;
		scanf("%d%d", &a, &b);
		graph[a].insert(b);
		graph[b].insert(a);
		adj[a].push_back(b);
		adj[b].push_back(a);
		Edge[a][b] = Edge[b][a] = 1;
	}
	for (i = 1; i <= n; i++) {
		if (!adj[i].empty()) {
			sort(adj[i].begin(), adj[i].end());
		}
		int sz = adj[i].size();
		C[i] = sz * (sz - 1) / 2;
	}
	for (i = 1; i <= n; i++) {
		for (auto &x : adj[i])IsNeighbor[x] = 1;
		for (auto &x : adj[i]) {
			if (adj[x].size() < adj[i].size() || (adj[x].size() == adj[i].size() && x < i)) {
				for (auto &y : adj[x]) {
					if (IsNeighbor[y])C[y]--;
				}
			}
		}
		for (auto &x : adj[i])IsNeighbor[x] = 0;
	}
```

$C$ 배열을 위와 같이 초기화하면 전체 시간복잡도 $O(E \sqrt E)$에 perfect elimination ordering을 구할 수 있다.

- Lexicographic breadth-first search

Lexicographic breadth-first search는 일반적인 breadth-first search와 거의 비슷한데, queue에서 빠지는 vertex를 어떻게 결정하는지가 조금 다르다. vertex $v$에 대해 $v$와 인접한 vertex 중 이미 방문한 vertex(queue에서 빠진 vertex)들의 방문순서를 정렬한 sequence를 $P(v)$라 하자. Lexicographic breadth-first search에서는 queue에 있는 vertex들 중 $P(v)$가 Lexicographically minimum인 vertex를 가장 먼저 방문한다(queue에서 제거한다). 일반적인 BFS와 비교하면 일반적인 BFS는 $P(v)$의 첫번째 원소가 minimum인 vertex를 방문하는데, Lexicographic BFS는 $P(v)$ 전체를 비교한다는 차이가 있다.

Lexicographic breadth-first search는 선형 시간에 구현할 수 있음이 알려져 있으며, $O(E log V)$ 시간복잡도를 가지는 간단한 구현이 존재한다. 이를 아래에 소개한다.
